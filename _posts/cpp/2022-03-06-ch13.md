---
title: "[Assembly] 1-13. 스택 메모리"
excerpt: "프로시저에 대해 알아본다."

categories:
  - cpp
tags:
  - [memory]

toc: true
toc_sticky: true

date: 2022-03-06
last_modified_at: 2022-03-06
---

## 스택 메모리
다음은 프로그램을 실행했을 때 저장되는 `메모리(RAM)`의 구조이다. `스택(stack)`은 이 중 하나의 영역을 차지하고 있는 것이다.
![01](https://user-images.githubusercontent.com/54501928/158011378-1c9c03f6-7613-4491-805a-d7a43902540d.png)

* `code` : 우리가 작성한 코드들이 저장되는 영역이다.
* `data` : 앞에서 다뤘던 `section .data` 이다. `bss`와 다르게 초기값이 존재한다.
* `bss` : 앞에서 다뤘던 `section .bss` 이다. 초기값은 무조건 0이라는 특징이 있다.
* `heap` : stack과의 차이점은 프로그래머가 원하는 때 직접 메모리에서 생성하거나 없앨 수 있다.
* `stack` : 특정한 프로시저에 돌입한 시점부터 프로시저(함수)가 끝나기 전까지(`ret`될 때까지) 여기에 필요한 `매개 변수`나 `돌아갈 주소의 값`을 저장하는 것이다.
    * 참고로 `컴파일 타임`에 크기가 결정된다고 보는 입장도 있고, `런타임`에 결정된다는 입장도 있는데 `빌드(build)`시 스택의 초기 사이즈가 정해지고, 프로그램이 실행되는 동안 스택의 크기가 유동적으로 증가할 수도 있으므로 `런타임`에 결정된다고 하는 것 같다.

![02](https://user-images.githubusercontent.com/54501928/158011970-3cb49e0c-949e-40ea-80d3-7b1ac8c48619.png)

스택은 `높은 주소`에서 `낮은 주소`로 쌓이는 구조이다. `main`에서 `func1` 프로시저를 호출하고, `func1`에서 `func2` 프로시저를 호출한 그림임을 알 수 있다. 위 구조를 `스택 프레임(Stack Frame)`이라고 부른다.

## IP, SP, BP
레지스터는 다양한 용도로 사용되며 여러 가지 종류가 있다.
* `rax`, `eax`와 같은 a b c d 범용 레지스터
* `포인터(pointer)` 레지스터 (포인터 = 주소(위치)를 가리키는 용도)
    * `IP(Instruction Pointer)` : 다음으로 수행할 명령어의 위치
    * `SP(Stack Pointer)` : 현재 스택의 top 위치 (일종의 `cursor`)
    * `BP(Base Pointer)` : 스택 `상대 주소` 계산용

이전까지 a b c d 범용 레지스터를 많이 다뤘으므로 이번에는 `IP`, `SP`, `BP`를 살펴보자.
```nasm
    push 1
    push 2
    push 3

    pop rax
    pop rbx
    pop rcx
```

위 명령어를 SASM에서 디버깅해보면 `rip`에 다음 실행될 명령어의 주소값이 들어있음을 알 수 있다. 이는 `IP`이며 64비트이므로 앞에 R이 붙어 `RIP`이 된 것이다.

`SP`는 `높은 주소`에서 `낮은 주소` 값으로 점점 줄어듦을 알 수 있다. `push 1`을 실행하면 `rsp`에 1이 들어간 곳의 주소값이 저장된다. `push 2`를 실행하면 1이 들어간 곳보다 8바이트 `낮은 주소`에 2가 들어가며 `rsp`또한 갱신된다. `push 3`도 동일하게 수행된다.

`pop`이 실행되면 스택에서 값을 꺼내 각각 `rax`, `rbx`, `rcx`에 저장한다. 위에서부터 저장된 값을 하나씩 꺼내는 것이므로 `rax=3`, `rbx=2`, `rcx=1`이다. 앞으로 `push`로 상수를 메모리에 저장했었지만 `pop`을 한다고 해당 영역에 딱히 변화가 생기는 건 아니다.

다음은 스택을 이용해 두 수 중 큰 값을 반환하는 예제이다.
```nasm
    push 1
    push 2
    call MAX
    PRINT_DEC 8, rax
    NEWLINE
    add rsp, 16         ; 넣지 않으면 crash. push 두 번 했으므로 rsp 위치도 제대로 돌려놔야함

    xor rax, rax
    ret

MAX:
    push rbp
    mov rbp, rsp
    
    mov rax, [rbp+16]   ; rax = 2
    mov rbx, [rbp+24]   ; rbx = 1
    cmp rax, rbx
    jg L1
    mov rax, rbx
L1:
    pop rbp
    ret
```

`rsp`는 `push`나 `pop`을 실행할 때마다 변하므로 이전 rbp값이 저장된 곳의 주소값을 `rbp`에 임시적으로 저장한다.
여기서도 `rax`, `rbx` 같은 중요한 레지스터들을 사용하고 있으므로 문제가 될 수도 있지만, 값을 바꾸기 전에 `push rax`, `push rbx`와 같이 스택에 저장해두면 그 문제는 해결될 것이다.

이미지 출처
* https://hyunable.github.io/2018/01/15/CS-memory/
* http://www.tcpschool.com/c/c_memory_stackframe