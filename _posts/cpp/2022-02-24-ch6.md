---
title: "[Assembly] 1-6. 문자열과 엔디안"
excerpt: "문자열과 엔디안에 대해 알아본다."

categories:
  - cpp
tags:
  - [string, endian]

toc: true
toc_sticky: true

date: 2022-02-25
last_modified_at: 2022-02-25
---

## 문자열이란?

어셈블리어에서는 데이터를 다음과 같이 표현할 수 있다.
```nasm
section .data
  a db 0x11
  b db 0x11, 0x11, 0x11, 0x11

  msg db 'Hello World', 0x00
```

`db`는 1바이트를 의미한다. 그러나 꼭 하나의 값만 넘겨야하는게 아니라 변수 b처럼 값 여러 개를 선언할 수도 있다.
변수 b의 주소 시작점부터 값이 `0x11, 0x11, 0x11 ,0x11` 일련으로 나열되는 구조이다.

또한 예제에서 변수 msg로 Hello World라는 문자열을 선언하고 있다.
0x00는 문자열의 종료를 의미한다. `Hello World`의 d 바로 뒤에 0x00값이 옴으로써 딱 d까지 문자열 값으로 들어가게 된다. 0x00가 없으면 컴퓨터는 어디까지 문자열로 인식할지 모른다. 따라서 0x00는 선언하고자 하는 문자열 뒤에 반드시 와야한다.

`H`,`e` 등의 문자들은 우리가 보기에는 알파벳의 형태지만 컴퓨터 입장에선 결국 하나의 값이다. 예를 들어 컴퓨터 입장에서 H는 72, e는 101 이라는 값으로 해석한다. 어떤 문자를 어떠한 값으로 매치시키기 위해 대표적으로 널리 쓰이는 것이 아스키 코드이다. A를 65, C를 67, [를 91 등으로 매치시키겠다는 그러한 약속이 아스키 코드로 규정된다.

![01](https://user-images.githubusercontent.com/54501928/155869237-b1d9bc98-774a-4dda-b886-80a84f4dd044.png)

결국 `H``e``l``l``o`` ``W``o``r``l``d` 각 문자는 1바이트를 차지하는 값에 불과하며, 문자열 또한 변수 b처럼 1바이트 값들이 일련으로 나열된 것에 불과하다. 즉 다음과 같다.
```nasm
section .data
  msg db 'Hello World', 0x00 ; 이것은 아래와 동일하다.
  msg db 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x00
```

문자열이란 사람 관점에서 보기 좋게 해석하는 것에 불과하며 실체는 일련의 값의 나열일 뿐이다.

## 엔디안
`엔디안(Endian)`이란 연속적으로 나열되어 있는 데이터를 어떻게 배열할 지 정의하는 것이다. 예제를 보면 이해하기 쉽다.
```nasm
section .data
  c dd 0x12345678
```

4바이트 크기의 변수 c를 선언하며 값을 0x12345678로 초기화시키고 있다. SASM에서 메모리를 보면 변수 c의 값이
```nasm
{0x78, 0x56, 0x34, 0x12}
```
로 나열되어 있다. 우리의 예상대로라면 친숙하게 `{0x12, 0x34, 0x56, 0x78}`가 되어야 했을 것이다.
SASM의 결과처럼 뒷자리 바이트가 앞으로 오는 순서를 `리틀 엔디안(Little-Endian)`이라고 부른다.
반면에 예측했던 앞자리 바이트가 앞으로 오는 순서를 `빅 엔디안(Big-Endian)`이라고 한다. 각 엔디안은 장단점이 있다.

* `리틀 엔디안` : 우리 입장에서는 불편해보이지만 캐스팅에 유리하다는 장점이 있다. 예를 들어 `0x12345678`에서 78만 남기고 나머지는 0으로 초기화한다고 가정하자. 빅 엔디안이라면 맨 뒷자리 주소까지 봐야하지만 리틀 엔디안은 맨 앞의 주소만 보면 된다.
* `빅 엔디안` : 숫자 비교에 유리하다는 장점이 있다. `0x12345678`과 `0x45123412` 두 수중에 어떤 값이 큰지 비교하는 상황이 생겼다고 하자. 맨 앞 자릿수부터 숫자를 서로 비교하면 빠르게 어떤 수가 큰지 결정할 수 있다. 

대부분 우리가 사용하는 컴퓨터 하드웨어(AMD, Intel 등)은 `리틀 엔디안(Little-Endian)`을 사용한다.
따라서 일반적으로는 리틀 엔디안을 사용하면 되지만, 서버에 데이터를 주고 받는 경우나 파일을 파싱하는 경우 엔디안 이슈가 은근히 잦으므로 의식해두는 것이 좋다.