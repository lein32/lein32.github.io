---
title: "[C++] 1-2 데이터 기초"
excerpt: "컴퓨터에서 다루는 데이터의 형태를 알아본다."

categories:
  - cpp
tags:
  - [bit, byte, radix]

toc: true
toc_sticky: true

date: 2022-02-23
last_modified_at: 2022-02-23
---

## 비트와 바이트
* `비트(bit)` : 0과 1, false와 true 처럼 두 가지 값만 가질 수 있는 측정 단위

* `바이트(Byte)` : `여덟 개의 비트(bit)`로 구성된 데이터의 양을 나타내는 단위. 즉 `1 byte = 8 bit`이다.

윈도우 계산기를 키고 프로그래머-비트 전환 키패드 를 눌러 알아보면 좋다.


## 워드(WORD), 더블워드(DWORD), 쿼드워드(QWORD)
일반적으로 다음과 같은 의미를 지닌다.

* `WORD` : `2바이트`. 즉 `1 WORD = 2 byte = 16 bit` 이다. 바이트의 2배라고 생각하면 된다.
* `DWORD` : `2워드`. 즉 `1 DWORD = 2 WORD = 4 byte = 32 bit` 이다. 더블워드이므로 워드의 2배이다.
* `QWORD` : `4워드`. 즉 `1 QWORD = 2 DWORD = 4 WORD = 8 byte = 64 bit` 이다. 쿼드워드이므로 워드의 4배이다.

1 바이트로 어떤 수 하나를 표현해본다고 가정하자. 총 8비트이므로 0부터 255까지(`0000000~11111111`) 표현이 가능할 것이다.

다만 음수를 표현하고 싶다면 위 방법을 그대로 사용할 수 없을 것이다. 생각할 수 있는 가장 간단한 방법은 맨 앞의 비트 하나를 부호 비트로 사용하는 것이다. 맨 앞의 비트가 `0`이면 양수, `1`이면 음수와 같이 말이다. 그러나 컴퓨터에서는 다음과 같은 결과값이 나온다.
```cpp
00000000 = 0
10000000 = -128 // 0이 아님!
```
우리가 생각한 방식대로라면 맨 앞의 비트만 1이므로 -0이 되어 값이 0이여야 하지만 실제로는 -128이라는 값이 나온다.

이는 단순히 맨 앞의 비트를 부호 비트로 사용한 게 다가 아니라는 것을 알 수 있다.

잘 생각해보면 우리가 생각한 방식은 0이라는 값을 무려 두 가지 방식으로 표현할 수 있다. 이는 어찌보면 비효율적이고 이상한 방식이다.


```cpp
01000000 = 64
10000000 = -128
```

두 번째 비트만 1일 때는 64로 양수이고, 첫 번째 비트만 1일 때는 -128로 음수임을 알 수 있다.

이를 보면 확실히 첫 비트가 부호에 관여하고 있음을 알 수 있다. 그러면 구체적으로 어떤 방식을 통해 음수를 표현하는 것일까?

바로 `2의 보수`라는 개념을 사용해 값을 구한다. `2의 보수`는 모든 비트를 반대로 바꾸고 그 값에 1을 더해 구할 수 있다. 예를 들어 12라는 수의 2의 보수를 구해보자.

```cpp
00001100 = 12

11110011       // 먼저 위에서 0은 1로, 1은 0으로 비트를 반전시킨다. (이 값을 1의 보수라고 한다)

11110100 = -12 // 반전시켜 나온 11110011에 1을 더하면 11110100이 된다. 이 값이 12의 2의 보수다.
```
위 방식에 따라 12를 00001100, -12를 11110100이라고 표현할 수 있다.

이 2의 보수가 정말로 정확한지 알아보려면 두 수를 더해보면 된다.
```cpp
  00001100
+ 11110100
-----------
1 00000000   // 올림으로 생긴 맨 앞의 1비트는 1바이트(8비트) 범위를 벗어나므로 버린다.

= 00000000
```

00001100 + 11110100이 곧 0임을 알 수 있다. 이로써 2의 보수가 데이터를 표현하기에 적합한 방식임이 증명되었다.

참고로 맨 앞의 비트를 일반적으로 `최상위 비트(Most Significant Bit, MSB)`라고 부른다. 또한 맨 뒤의 비트는 `최하위 비트(Least Significant Bit, LSB)`라고 부른다.

## 2진수, 10진수, 16진수
우리는 일상에서 10진수를 이용한다. `10진수`란 `0 1 2 3 4 5 6 7 8 9`를 이용해 수를 표현하는 체계이다. 10진법에서 9라는 수보다 1 커지면 해당 자릿수는 0으로 변하고 대신 앞에 1이 추가적으로 붙어 10이 된다.

`2진수`는 컴퓨터가 주로 사용하는 방식이다. 컴퓨터 입장에서 상태가 0인지 1인지만 알면 끝이기 때문에 편리하다. 2진법에서 만약 1이라는 수보다 1 커지면 해당 자릿수는 0이 되고 대신 앞에 1이 붙어 10이 된다. 이 2진수에서의 10은 10진수로 표현하면 3이니 헷갈리지 않도록 주의한다.

`16진수`는 숫자를 16개(`0 1 2 3 4 5 6 7 8 9 A B C D E F`) 사용하여 표현한 것이다. 즉 10을 16진법으로 표현하면 A가 되고, 15는 16진법으로 표현하면 F가 된다. 16은 16진법으로 표현하면 어떻게 될까? 다른 진법과 마찬가지로 해당 자릿수가 0이 되는 대신 앞에 1이 붙는다. 따라서 16은 16진법으로 10이다. 2진수는 숫자가 조금만 커져도 자릿수가 상당히 늘어난다는 단점이 있는데 16진수가 이를 보완한다.

프로그래밍을 할 때 일반적으로 아래와 같은 방식으로 수를 표현한다.
* `10진수` : 사람 입장에서 타이핑하는 경우가 가장 많은 수가 10진법이므로 그냥 쓰면 된다. 15, 32... 처럼 말이다.
* `2진수` : 숫자 앞에 `0b` 또는 `0B`를 붙이면 2진법으로 표현한다는 의미이다. `00110011`이 110011(십일만십일)이면 `0b00110011`에서의 00110011은 2진수이므로 10진수로 51이다.
* `16진수` : 숫자 앞에 `0x` 또는 `0X`를 붙이면 16진법으로 표현한다는 의미이다. `12`이 12(십이)면 `0x12`은 16진수 12이므로 10진수로 18이다.


## 16진수와 2진수의 관계
16은 2의 4제곱, 즉 `16 = 2^4`이다. 따라서 16진수와 2진수 사이의 변환은 매우 간단하다. 아래의 예시를 보자.
```cpp
0b10110101       // 2진수 10110101 을 16진수로 변환하는 예시

1011 0101        // 위 2진수를 보기 좋게 네 자리 단위로 쪼갠다.

1011             // 1011은 10진수로 11이다. 11은 16진수로 B이다.
0101             // 0101은 10진수로 5이다. 5는 16진수로 5이다.

1011 0101 = 0xB5 // 위에서 B와 5를 붙여쓰면 B5, 따라서 2진수 10110101을 16진법으로 표기하면 0xB5이다.
```

16진수의 자릿수 하나가 2진수의 네 자릿수로 구성된다는 것이 핵심이다.
