---
title: "[Assembly] 1-12. 프로시저"
excerpt: "프로시저에 대해 알아본다."

categories:
  - cpp
tags:
  - [procedure, function]

toc: true
toc_sticky: true

date: 2022-03-06
last_modified_at: 2022-03-06
---

## 프로시저
어셈블리에서는 함수가 없고 `프로시저(Procedure)`라는 것이 존재한다. 하지만 C, C++, Java 등 대부분의 언어에서 말하는 함수와 동일하다. `서브루틴(subroutine)`이라고도 부른다.

`프로시저`는 코드를 분할해 작성하고 거기에 이름을 붙인 것이다. 주로 반복적으로 실행하고자 하는 코드는 프로시저로 작성한다. 즉 프로시저는 재사용 가능한 코드의 집합이라고 할 수 있다.
```nasm
    call PRINT_MSG      ; 프로시저를 호출
    xor rax, rax
    ret

PRINT_MSG:
    PRINT_STRING msg
    NEWLINE
    ret

section .data
    msg db 'Hello World', 0x00
```

`call [프로시저명]` 명령어를 통해 `PRINT_MSG:` 아래의 코드를 실행한다. 프로시저의 특징은 `ret`를 통해 프로시저의 끝을 알려야 한다는 점이다. 이것이 `jmp`로 이동하는 것과의 차이점이다.

프로시저에는 값을 넘길 수도 있다. 위 예제에서는 아무 값도 넘기고 있지 않지만, 예를 들어 프로시저에 두 개의 값을 넘기고 그 중에 큰 값을 프로시저가 `반환(return)`하도록 할 수 있다. 우선 생각할 수 있는 방법은 다음과 같다.
```nasm
    mov eax, 10
    mov ebx, 15
    call MAX
    PRINT_DEC 4, ecx
    
    xor rax, rax
    ret

MAX:
    cmp eax, ebx
    jg L1
    mov ecx, ebx
    jmp L2
L1:
    mov ecx, eax
L2:
    ret
```

위 기능은 두 수만 비교하면 됐기 때문에 프로시저 없이 `eax`와 `ebx`을 이용해 구현할 만 했다. 그런데 만약 10개의 숫자를 비교해야 한다면 어떨까? 우리가 이용할 수 있는 레지스터의 수는 턱없이 부족하며, 기존에 사용하고 있던 레지스터 값은 또다른 어딘가에 저장해야 하므로 매우 불편할 것이다.

두 번째로 생각할 수 있는 방법은 다음과 같이 변수를 선언해 비교하는 것이다.
```nasm
CMAIN:
    ; 여기서 비교하는 함수 호출
    ...

    xor rax, rax
    ret
section .data
    a dd 0
    b dd 0
    c dd 0
    ...
```
그러나 이 또한 인자가 많이 필요하다면 복잡해진다는 문제점이 있으며, 값을 임시적으로 비교하는 용도로 사용하기엔 너무나 낭비가 심하다. 값 비교 용도로 선언한 것인데 `data` 섹션에는 값을 비교할 때든 안할 때든 해당 변수들이 계속 메모리에 남아있을 것이기 때문이다. 따라서 다른 메모리 구조가 필요하다는 결론을 얻을 수 있다.

이를 위한 해결 방법은 `스택(stack)`이라는 메모리 영역을 사용하는 것이다. 프로시저가 사용하는 일종의 메모장이라고 할 수 있으며, `매개 변수 전달`, `돌아갈 주소 관리` 등의 역할을 한다. `스택`의 조건은 다음과 같다.
* 해당 프로시저가 완전히 끝나기 전까지는 유효해야 한다
    * `유효 범위`가 존재
* 해당 프로시저가 완전히 끝나면(`ret`되면) 기존의 저장된 값들은 불필요하므로 메모리에서 없애버려도 된다.
    * 프로시저가 끝나면 `정리` 해버림
* 프로시저에서 또 다른 프로시저를 호출할 수도 있으므로 이를 고려해야함
    * 유동적으로 `유효 범위`가 확장 가능해야 함

`스택`에 대해서는 다음 챕터에서 다룬다.