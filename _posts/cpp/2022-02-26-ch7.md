---
title: "[Assembly] 1-7. 사칙연산"
excerpt: "어셈블리에서의 사칙연산에 대해 알아본다."

categories:
  - cpp
tags:
  - [string, endian]

toc: true
toc_sticky: true

date: 2022-02-26
last_modified_at: 2022-02-26
---

## 사칙연산
SASM에서 지원하는 `GET_DEC` 라는 함수를 통해 Input 창에서 입력을 받을 수 있다.

```
GET_DEC [입력받을 바이트 크기], [저장될 메모리 혹은 레지스터]
```

또한 `PRINT_DEC`는 바이트 크기만큼 저장된 곳의 값을 정수 형식으로 출력하는 함수이다.

```
PRINT_DEC [출력할 바이트 크기], [출력할 메모리 혹은 레지스터]
```


`NEWLINE`은 한 줄 개행하는 함수이다. 엔터를 쳐서 다음 줄로 넘어간 것과 동일하다고 생각하면 된다.

```nasm
CMAIN:
    GET_DEC 1, al
    GET_DEC 1, num

    PRINT_DEC 1, al
    NEWLINE
    PRINT_DEC 1, num
section .bss
    num resb 1
```

더하기 연산은 `add a, b` 형식으로 작성한다. 규칙은 다음과 같다.
* a는 `메모리 or 레지스터`
* b는 `메모리 or 레지스터 or 상수`
* 단 a와 b 둘 다 `메모리`일 수는 없다.

```nasm
CMAIN:
; al은 1, num은 2를 입력받았을 때

    add al, 1           ; 레지스터 + 상수
    PRINT_DEC 1, al     ; 1 + 1 = 2
    NEWLINE

    add al, [num]       ; 레지스터 + 메모리. num이면 al에 num의 주소값을 더하게 되므로 에러.
    PRINT_DEC 1, al     ; 2 + 2 = 4
    NEWLINE    

    mov bl, 3
    add al, bl          ; 레지스터 + 레지스터
    PRINT_DEC 1, al     ; 4 + 3 = 7
    NEWLINE

    add [num], byte 1   ; 메모리 + 상수. 레지스터와 달리 변수의 크기는 모르므로 byte로 1바이트짜리 상수임을 명시
    PRINT_DEC 1, [num]  ; 2 + 1 = 3
    NEWLINE

    add [num], al       ; 메모리 + 레지스터
    PRINT_DEC 1, [num]  ; 3 + 7 = 10
    NEWLINE

    add [num], [num]    ; 메모리 + 메모리 (X) 에러

    xor rax, rax
    ret
```

그 외에
* 빼기 연산은 `sub a, b` 형식으로 작성한다. 규칙은 더하기 연산과 동일하다.
* 곱하기 연산은 `mul 레지스터` 형식으로 작성한다. 곱셈의 연산 결과는 기본적으로 a 레지스터에 저장된다. 예를 들어
    - `mul bl`은 al * bl 값을 ax에 대입하는 것과 같다. 
    - `mul bx`은 ax * bx 값을 dx(상위 16비트) ax(하위 16비트)에 저장된다.
    - ...

```nasm
; ex) 6 * 9 구하기
    mov ax, 0
    mov al, 5
    mov bl, 8
    mul bl
    PRINT_DEC 2, ax
```

* 나누기 연산은 `div 레지스터` 형식으로 작성한다.
    - `div bl`은 ax / bl이며 연산 결과는 al(몫) ah(나머지)

```nasm
; ex) 100 / 3 구하기
    mov ax, 100
    mov bl, 3
    div bl
    PRINT_DEC 1, al     ; 몫
    NEWLINE
    mov al, ah          ; ah는 PRINT_DEC으로 출력 불가능해 al에 복사
    PRINT_DEC 1, al     ; 나머지
```