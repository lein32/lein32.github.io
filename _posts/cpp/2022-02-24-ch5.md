---
title: "[Assembly] 1-5. 변수와 레지스터"
excerpt: "변수와 레지스터의 관계를 알아본다."

categories:
  - cpp
tags:
  - [memory, register, data, bss]

toc: true
toc_sticky: true

date: 2022-02-24
last_modified_at: 2022-02-24
---

## 메모리와 레지스터

컴퓨터에 있는 파일들은 `하드디스크`에 저장되고, 이를 실행하면 `메인 메모리`에 올라가며 이 정보를 CPU의 `레지스터`에 가져와 연산을 한다고 했다.

앞으로 얘기하는 `메모리`는 `메인 메모리`라고 가정한다. 프로그래머 입장에서 `레지스터`와 `메모리` 사이에 값을 어떻게 주고받을 수 있을까? 예를 들어 `레지스터`로 `메모리` 값을 어떻게 불러오고, 반대로 `메모리`에 `레지스터`에 들어있는 값을 어떻게 저장할 수 있을까?

## Data 영역, BSS 영역

![01](https://user-images.githubusercontent.com/54501928/155619384-2a4b118c-6337-4f76-b3bc-fc04506f28ba.png)

메모리에는 다음과 같은 구조로 차지하는 영역이 존재한다. 여기서는 `Data` 영역과 `BSS`영역에 대해 살펴본다.

```nasm
    ; 데이터 영역, BSS 영역 둘다 변수를 저장하는 영역이다. (변수는 값(데이터)를 저장하는 상자이다)
    ; 상자의 이름과 크기를 지정한다. 이를 변수의 선언이라고 한다

    ; ===데이터 영역===
    ; 초기화 된 데이터
    ; [변수이름] [크기] [초기값]
    ; [크기] db(1) dw(2) dd(4) dq(8)
section .data
    a db 0x11   ; [0x11]
    b dw 0x2222
    c dd 0x33333333
    d dq 0x4444444444444444


    ; ===BSS 영역===
    ; 초기화 되지 않은 데이터
    ; [변수이름] [크기] [개수]
section .bss
    e resb 10
```

data 영역과 bss 영역의 차이점은 `초기화 여부`이다. 굳이 초기화로 차이를 둔 이유는 `data 영역`에서는 초기화하는 값이 존재한다. 즉 어떤 값으로 초기화할 것인지 알아야하므로 `파일`에도 이 값을 기록해야 한다. 그러나 `bss 영역`에서는 초기값이 무조건 0이므로 이를 기록할 필요가 없고 지정되는 크기만 알면 된다.

## 메모리 -> 레지스터

위에서 data 영역과 bss 영역을 작성한 대로 `메모리`에 올라간다. 그렇다면 이 메모리에 있는 변수값들을 `레지스터`에 저장할 수 있을까? 먼저 아래의 예시를 보자.
```nasm
    ; 위 예시처럼 data와 bss 영역이 작성된 상태라고 가정하자.
    mov rax, a      ; a라는 상자의 주소값을 rax에 복사
```
rax에 a를 대입했으므로 rax에는 a의 값인 0x11이 들어가있을 것 같지만, 실제로는 0x11이 아닌 0x403010과 같은 값이 들어가 있다. 이것은 변수 a의 메모리 주소값이다. 각 변수에는 메모리 주소값이 존재하며, 이 주소안에 우리가 저장한 값들이 들어있다고 생각하면 된다. 이해하기 쉽게 비유를 하자면 아파트와 같다.
![02](https://user-images.githubusercontent.com/54501928/155623109-21fdbfed-b61d-4e26-b9e6-cce38edc7305.png)

예를 들어 아파트에 변수 a라는 사람과 변수 b라는 사람이 살고 있고

변수 a의 주소는 102호, 변수 b의 주소는 103호이다.

102호 안에는 0x11 개의 물건이 들어있고, 103호 안에는 0x2222 개의 물건이 들어있다.

라고 생각하면 된다. 이 예시를 따르면 `mov rax, a`에서 a는 102호에 살고 있으므로 rax에는 102가 담겨있는 것이다.

그림에서는 a와 b가 서로 붙어있지만 실제로는 주소가 a, b가 나란히 붙어있지 않을 수도 있다. a가 102호면 b는 305호일 수도 있는 것이다.

우리가 원하는건 주소값이 아니라 주소안에 들어있는 값이다. rax에 a의 주소값이 아닌 a에 저장되어 있는 값을 넣으려면 다음과 같이 한다.
```nasm
mov rax, [a]       ; a라는 상자 안에 들어있는 값을 rax에 복사 
```

`[ ]`로 감싸주면 해당 변수 안의 값을 참조한다. 그러나 결과는 rax에 0x11이 제대로 저장되지 않는데, 이는 mov할 때 몇 바이트만큼 복사할 것인지 써두지 않았기 때문이다. 실제로 변수 a의 주소값으로부터 8바이트 만큼 저장된다. `(rax가 8바이트이기 때문에 rax만큼 저장한다)`

대입하는 사이즈가 레지스터의 크기로 고정되어 있으므로 다음과 같이 작성해야 우리가 원하는 결과로 나올 것이다.
```nasm
mov rax, 0      ; rax를 0으로 초기화
mov al, [a]     ; al에 0x11를 대입
```

al이 rax의 최하위 1바이트이고 변수 a또한 1바이트 이므로 최종적으로 rax 레지스터는 0x11이라는 값을 지닌다.

## 레지스터 -> 메모리

`메모리`에서 `레지스터`로 저장한 방식과 비슷하다. 다만 대입할 때 상수값의 사이즈는 명시해야 한다는 차이점이 있다.
```nasm
mov [a], byte 0x55      ; 변수 a에 1바이트만큼 복사하겠다. 그 복사할 값은 0x55
mov [a], word 0x6666    ; 변수 a에 2바이트만큼 복사하겠다. 그 값은 0x6666
mov [a], cl             ; cl 레지스터의 사이즈는 1 바이트란걸 안다. 레지스터의 값을 저장할 때는 사이즈 명시 X
```

이미지 출처
* https://ehclub.co.kr/684