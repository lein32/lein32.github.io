---
title: "[C++] 2-3. 문자와 문자열"
excerpt: "C++에서 문자와 문자열을 표현하는 방법에 대해 알아본다."

categories:
  - cpp
tags:
  - [boolean, float, double]

toc: true
toc_sticky: true

date: 2022-03-09
last_modified_at: 2022-03-09
---

## 문자
`char` : 알파벳, 숫자 문자를 나타낸다. `(ASCII에 대응)`

`wchar_t` : 유니코드 문자를 나타낸다. `(UTF-16에 대응)`


`char`를 단순히 정수를 담기 위해 사용할 수도 있지만 일반적으로는 `문자`라는 의미로 저장하기 위해 사용한다.

`아스키코드(ASCII;American Standard Code for Information Interchange)`에 의해 97이라는 값은 A라는 문자를 나타낸다.

즉 A라는 문자는 컴퓨터에겐 그저 97이라는 하나의 숫자일 뿐이다. 인간이 쓰는 문자를 아스키코드 값으로 변환하기 위해서는 `작은따옴표(')`로 문자를 감싸야 한다. 따라서 `97`대신 `'A'`이라고 쓰면 직관적으로 문자라는 의미를 나타낼 수 있다.

```cpp
// a와 b는 서로 동일하다.
char a = 97;
char b = 'A';

char c = 'a';
char d = '1';
char e = 'a' + 1;   // b
```

아스키코드는 `영어, 숫자, 일부 특수문자`만 표현이 가능하다는 문제점이 있다. 따라서 한국어, 일본어, 중국어 같은 언어들은 표현할 수 없다. 컴퓨터가 문자를 표현하기 위해서는 어찌됐든 어떤 값과 매핑을 꼭 시켜야하는데, 전세계의 모든 문자를 비롯한 다양한 특수문자를 표현할 수 있도록 나온 것이 `유니코드(unicode)`이다.

유니코드는 표기 방식에 여러가지가 있는데, 대표적으로 `UTF-8`과 `UTF-16`이 있다.

#### `UTF-8`
- 알파벳, 숫자 1바이트 (ASCII 동일한 번호)
- 유럽 지역의 문자는 2바이트
- 한글, 한자 등 3바이트

#### `UTF-16`
- 알파벳, 숫자, 한글, 한자 등 거의 대부분 문자는 2바이트
- 예외적으로 소수의 고대 문자, 몇몇 특수 문자는 4바이트 (사실상 무시해도 된다)

마이크로소프트 사에서는 주로 `UTF-16`을 사용하며 이는 `wchar_t`에 대응된다.

```cpp
#include <iostream>
using namespace std;

wchar_t wch = L'안';

int main()
{
    cout << wch << endl;    // 50504
}
```

문자를 감싼 작은따옴표 앞에 `L`을 붙여 유니코드임을 명시한다.

cout 자체는 `char` 전용 이기 때문에 유니코드를 제대로 출력하지 못한다. 따라서

```cpp
#include <iostream>
using namespace std;

wchar_t wch = L'안';    // wchar_t wch = 0xc548; 과 동일하다

int main()
{
    wcout.imbue(locale("kor")); // 로케일을 한국어로 설정한다.
    wcout << wch << endl;       // 안
}
```

`wcout`은 유니코드를 출력할 수 있게 해준다.

wcout은 기본적으로 영어만 알고 한국어를 모르기 때문에 로케일을 한국어로 설정하는 과정이 필요하다. 만약 해당 라인을 지우면 한글이 출력되지 않는다.

백슬래시(\) 뒤에 한 문자나 숫자 조합이 오는 문자 조합을 `이스케이프 시퀀스(Escape Sequence)`라고 한다. 줄바꿈 문자, 작은따옴표, 탭 문자 등을 나타내려면 이를 이용해야 한다. 예를 들어
```cpp
// \0 = 아스키코드 0 = NULL
// \t = 아스키코드 9 = Tab
// \n = 아스키코드 10 = Line Feed (커서를 한줄 아래로)
// \r = 아스키코드 13 = Carriage Return (커서를 맨 앞으로 이동)

// 엔터키를 눌러 줄바꿈을 하는 것은 \r\n과 동일하다고 보면 된다.
char a = '\'';  // 작은따옴표 ' 저장
char b = '\t';  // 탭문자 저장
```

이스케이프 시퀀스 목록은 https://docs.microsoft.com/ko-kr/cpp/c-language/escape-sequences?view=msvc-170 를 참고한다.


## 문자열
문자들이 열을 지어서 모여 있는 것을 `문자열`이라고 한다. 문자들이 배열의 형태로 나열된 것이라고 할 수 있다. 정수나 실수를 저장할 때는 바이트 크기가 고정되었지만 문자열은 문자가 모여 구성되므로 전용 데이터 타입이 존재하지 않는다. `문자열`의 특징은 데이터 맨 뒤에 `널 문자(\0)`가 온다는 점이다. `널 문자(\0)`로 문자열이 어디까지인지 판단하므로 반드시 존재해야 한다. 널 문자의 아스키 코드 값은 0이다.

```cpp
// example 1
char str[] = { 'h', 'e', 'l', 'l', 'o' };

int main()
{
    cout << str << endl;    // hello 출력
}
```

위 예시에서 str은 전역변수로 선언되어 `데이터 영역`에 존재하므로 그 외의 영역엔 초기값이 0으로 지정되어 운 좋게 아스키코드로 0인 널 문자가 들어간다. 하지만 아래 예시의 경우

```cpp
// example 2

int main()
{
    char str[] = { 'h', 'e', 'l', 'l', 'o' };

    cout << str << endl;    // hello가 정상적으로 출력되지 않는다.
}
```

`스택 영역`에 저장되어 str의 o 다음 부분들이 0으로 초기화가 되지 않는다.
str의 맨 끝에 `널 문자(\0)`가 오지 않았으므로 메모리 상에서 o 뒤에 있는 값들을 전부 읽는다. 운 좋게 뒷부분에서 널 문자를 만나면 딱 거기까지 출력되는 것이다. 이는 아래와 같이 해결한다.

```cpp
// example 3

int main()
{
    char str[] = { 'h', 'e', 'l', 'l', 'o', '\0'};

    cout << str << endl;    // hello가 정상적으로 출력된다.
}
```

문자열의 맨 끝은 항상 `널 문자(\0)`로 끝나야 함을 보여준다.

지금까지 문자열을 선언하는 방법을 살펴보았는데 위와 같은 방식들은 타이핑하기 참 번거롭다는 걸 알 수 있다. 따라서 일반적으로 아래의 방식을 사용한다.
 ```cpp
// example 4

int main()
{
    char str[] = "hello";

    cout << str << endl;    // hello가 정상적으로 출력된다.
}
```

문자열을 입력하고 `큰따옴표(")`로 감싸면 된다. 맨 뒤에 널 문자는 자동적으로 들어가기 때문에 일부러 넣어줄 고생은 하지 않아도 된다. 널 문자까지 전부 포함된 것이기 때문에 실제 str가 차지하는 총 바이트 크기는 6이다. hello(5) + NULL(1) = 6 바이트 인 것이다. 유니코드 문자열이라면 다음과 같은 방식으로 써주면 된다.

```cpp
wchar_t str[] = L"hello";
```
