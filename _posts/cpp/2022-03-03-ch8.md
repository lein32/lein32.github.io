---
title: "[Assembly] 1-8. 쉬프트 연산, 논리연산"
excerpt: "쉬프트 연산과 논리연산에 대해 알아본다."

categories:
  - cpp
tags:
  - [shift, logical]

toc: true
toc_sticky: true

date: 2022-03-03
last_modified_at: 2022-03-03
---

## 쉬프트 연산
비트를 왼쪽 혹은 오른쪽으로 `n`칸만큼 이동시키는 연산이다.

예를 들어 `11010010`를 오른쪽으로 한칸 이동시키면 `01101001`이 된다.

`11010010`을 왼쪽으로 한칸 이동시키면 `10100100`이 된다. 일반적으로 빈 공간은 0으로 채워지게 된다.
```nasm
    mov eax, 0x12345678
    PRINT_HEX 4, eax    ; 결과: 0x12345678
    NEWLINE

    shl eax, 8          ; 왼쪽으로 8바이트만큼 쉬프트 
    PRINT_HEX 4, eax    ; 결과: 0x34567800
    NEWLINE
    
    shr eax, 8          ; 오른쪽으로 8바이트만큼 쉬프트
    PRINT_HEX 4, eax    ; 결과: 0x00345678
```

범위를 넘어가버린 1은 다시 1로 복구되지 않는다. 예를 들어

`11010010`을 왼쪽으로 한칸 이동시켰다가 오른쪽으로 한칸 이동시키면

`11010010` -> `10100100` -> `01010010`이 되고 초기값 `11010010`과 다른 `01010010`이 되었음을 알 수 있다.

## 곱셈 나눗셈과의 관계

쉬프트 연산으로 왼쪽으로 n칸 이동시키면 `10진수 기준`으로 해당 값에 2^n 을 곱한 것과 같다.

* `00001001`은 10진법으로 9이고 왼쪽으로 한칸 이동시킨 `00010010`은 18이다. `(9 * 2^1)`
* `00001001`은 10진법으로 9이고 왼쪽으로 두칸 이동시킨 `00100100`은 36이다. `(9 * 2^2)`

쉬프트 연산으로 오른쪽으로 n칸 이동시키면 `10진수 기준`으로 해당 값을 2^n 으로 나눈 것과 같다.

* `00100100`은 10진법으로 36이고 오른쪽으로 한칸 이동시킨 `00010010`은 18이다. `(36 / 2^1)`
* `00100100`은 10진법으로 36이고 오른쪽으로 두칸 이동시킨 `00001001`은 9이다. `(36 / 2^2)`

주의할 점은 왼쪽 쉬프트 연산 후에 `맨 앞의 비트(부호 비트)`가 1이 되면 음수로 변한다.

* 10진수 123인 `01111011`에 왼쪽 쉬프트 연산 1칸을 적용하면 `11110110`이며 이는 -10이다.

또한 음수에 오른쪽 쉬프트 연산을 하면 `맨 앞의 비트(부호 비트)`가 0이 되므로 양수로 변한다.

`11010010`은 -46으로 음수지만 오른쪽으로 한칸 이동시킨 `01101001`은 105로 양수이다.

## 논리 연산
어떠한 조건에 따라 비트를 0 또는 1로 변환시키는 연산이다.

수학 시간에 배운 명제를 떠올리면 좋다. `안경을 쓰고 있다.`라는 명제가 있다고 가정하자. 이를 부정하면 `안경을 쓰고 있지 않다`이다. 이렇게 인간이 자연어로 표현할 때, 컴퓨터에서는 0과 1로 대응해 조건을 표현한다. 예를 들어 1을 `사과를 좋아한다.`로, 0을 `사과를 좋아하지 않는다.`로 표현할 수 있다. 

논리 연산으로 다음과 같은 연산들이 있다.

* 비트가 1인 것을 0으로, 0인 것을 1로 바꾼다. 이를 `NOT` 연산이라고 한다.

* 두 비트가 모두 1이면 결과값이 1, 그렇지 않으면 0이다. 이를 `AND` 연산이라고 한다.

* 두 비트 중 하나라도 1이면 결과값이 1, 아니면 0이다. 이를 `OR` 연산이라고 한다.

* 두 비트가 서로 다르면 결과값이 1, 아니면 0이다. 이를 `XOR` 연산이라고 한다.

```nasm
    mov al, 0b01001101
    mov bl, 0b01111000

    not al              ; al의 not 연산
    PRINT_HEX 1, al     ; al = 0b10110010
    NEWLINE

    and al, bl          ; al와 bl의 and 연산 (0b10110010 AND 0b01111000)
    PRINT_HEX 1, al     ; al = 0b00110000
    NEWLINE

    or al, bl           ; al와 bl의 or 연산 (0b00110000 OR 0b01111000)
    PRINT_HEX 1, al     ; al = 0b01111000
    NEWLINE

    mov bl, 0b10011011  ; bl = 0b10011011
    xor al, bl          ; al와 bl의 xor 연산 (0b01111000 XOR 0b10011011)
    PRINT_HEX 1, al     ; al = 0b11100011
```