---
title: "[C++] 1-3 레지스터 기초"
excerpt: "레지스터의 역할이 무엇인지 알아본다."

categories:
  - cpp
tags:
  - [register, assembly]

toc: true
toc_sticky: true

date: 2022-02-24
last_modified_at: 2022-02-24
---

## 레지스터의 역할

CPU가 어떤 연산을 하는 동안 연산 중간결과를 하나씩 저장해야 한다. 이 때 바로 레지스터에 저장한다.

레지스터는 CPU에 내장되어 있으므로 속도가 굉장히 빠르다.


## 레지스터의 종류

일반적으로 `AX`, `BX`, `CX`, `DX` 가 존재하며 그 외에 `BP`, `SP`, `SI`, `DI` 등도 존재한다.

![01](https://user-images.githubusercontent.com/54501928/155613059-61626a27-3aa1-463e-93db-d6b33c50da17.png)

32 bit라면 맨 앞에 E가 붙고, 64 bit는 맨 앞에 R이 붙는다. 요즘 나오는 컴퓨터들은 대부분 64 bit를 사용하므로 `RAX`, `RBX`, `RCX`, `RDX` 라고 보면 된다.

`AX`는 16 bit이며 이를 `AH`, `AL` 로 8 bit씩 다시 나눌 수 있다. BX또한 BH, BL로 나뉘어지며 다른 것들도 마찬가지이다.


## 어셈블리

C++ 강좌이지만 우선 어셈블리라는 것을 간단히 살펴본다. 어셈블리는 기계어 다음으로 가장 로우한 레벨의 언어라고 할 수 있다. 어셈블리를 알면 내부적으로 프로그램이 어떤 연산을 통해 동작하는지 알아보기 쉽다.

가령 C++에서는 레지스터를 접해볼 기회가 흔치 않지만 어셈블리는 로우 레벨에서 제어가 가능하기 때문에 레지스터와 관련된 연산을 할 수 있다.

어셈블리에서 레지스터에 값을 대입할 때는 다음과 같이 쓴다.
```cpp
mov 레지스터명, 대입할 값       ; 기본 형식

mov eax, 0x1234               ; eax에 0x1234를 대입
mov rbx, 0x12345678           ; rbx에 0x12345678를 대입
mov cl, 0xff                  ; cl에 0xff를 대입
```

위에 레지스터 사진을 참고하며 값 대입에 유의한다. 예를 들어 al에 0x1234를 대입하면 에러가 발생할 것이다. al은 저장용량이 1 byte = 8 bit 인데 0x1234는 2 byte = 16 bit이기 때문이다. (16진수에서 각 자릿수가 4 bit를 차지한다)

만약 eax에 0x1234를 대입하고 그 후 al에 0x00를 대입하면 어떻게 될까? 다음과 같이 말이다.
```cpp
mov eax, 0x1234
mov al, 0x00
```
결과는 eax의 값이 0x1200으로 변한다. 0x1234는 eax의 하위 2바이트 (ax 영역)에 대입되며,
이 상태에서 al에 0x00을 대입하면 결국 ax 영역은 0x1200이 되어버린다. 따라서 eax의 값은 0x1200이 된다.

더 풀어서 써보자면 처음에 `mov eax, 0x1234`는 곧 `mov eax, 0x00001234`와 동일하다.
`mov al, 0x00`을 실행하면 `eax`는 `0x00001200`이 될 것이다.