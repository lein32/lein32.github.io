---
title: "[C++] 2-2. bool과 실수 타입"
excerpt: "bool과 실수를 표현하는 타입에 대해 알아본다."

categories:
  - cpp
tags:
  - [boolean, float, double]

toc: true
toc_sticky: true

date: 2022-03-09
last_modified_at: 2022-03-09
---

## 불리언(boolean)

`참(true)`혹은 `거짓(false)` 두 가지 값을 나타낼 수 있는 데이터 타입이다. C++에서는 다음과 같이 `bool`로 나타낸다.

```cpp
bool isPlayer = true;
bool isMale = false;
```

`bool`은 `1바이트 정수형` 타입이다.

어셈블리에서 bool이라는 타입은 없고 그저 하나의 정수일 뿐이다. C++에서 bool이라는 타입만 봐도 값이 `참`과 `거짓` 둘 중 하나뿐이다 라는 걸 알 수 있으므로 가독성이 증가하며 이는 프로그래머에게 편안함을 준다. 만약 어셈블리였다면 isMale = 1을 true, isMale = 0을 false와 같은 방식으로 표현했을 것이며 이는 직관적이지 않고 오히려 어색하다는 느낌이 든다. 하지만 bool 타입을 이용하면 의미가 자연스러워 보인다.

true와 false 두 가지 값을 표현하는 데엔 이론상 1비트만 있으면 충분할테지만 실제로는 `1바이트`다. 왜 1비트로 정하지 않았을까? 앞에서 어셈블리를 다룰 때 느꼈겠지만 레지스터에 저장할 때나 CPU에서 연산할 때 최소 단위는 바이트였다. 즉 하드웨어 설계상 연산의 최소 단위가 1바이트 이므로 bool도 1바이트로 정해진 것이라고 보면 된다.

## 실수
 정수를 포함한 `3.141592`와 같은 소수까지 표현할 수 있는 타입이 존재한다. `float`이나 `double`이 그 예다.
 ```cpp
float speed = 1.25f;    // 4바이트
double pi = 3.141592;   // 8바이트
 ```

실수형 상수는 기본적으로 `double`이라고 인식하기 때문에 `float`형 상수로 지정하고 싶으면 `speed` 변수처럼 숫자 맨 뒤에 f를 붙여주어야 한다.

`float`은 4바이트, `double`은 8바이트이다. 

컴퓨터에서 실수를 표현할 때는 `부동소수점`이라는 방식을 사용한다. `부동(浮動)`은 움직이지 않는다가 아니라 둥둥 떠서 움직인다는 의미다. 따라서 소수점이 둥둥 떠서 움직인다는 것으로 받아들이면 될 것이다. 부동소수점 방식은 예시의 방법처럼 계산한다.
```cpp
// 3.1415926535 = 0.31415926535 * 10 = 314.15926535 * 10^(-2)
// 1) 정규화 = 0.31415926535 * 10
// 2) 31415926535 (유효숫자) 1 (지수. 10의 n제곱)

// float은 부호로 1비트, 지수를 8비트, 유효숫자를 23비트 = 32비트 = 4바이트
// double 부호로 1비트, 지수를 11비트, 유효숫자를 52비트 = 64비트 = 8바이트
```

`float`은 부호(1) + 지수(8) + 유효숫자(23) = 32비트 = `4바이트`

`double`은 부호(1) + 지수(11) + 유효숫자(52) = 64비트 = `8바이트`

`double`의 지수와 유효숫자를 표현할 수 있는 비트가 더 크므로 float보다 정밀도가 높다고 할 수 있다.

```cpp
// <예제. float형 -3.375라는 값을 저장>
// 0.375 = (0.5 * 0) + (0.25 * 1) + (0.125 * 1) = 0b0.011

// 1) 2진수 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 2) 정규화 0b1.1011 * (2^1)  즉 지수 = 1
// 1(부호) 1(지수) 1011(유효숫자)

// 단 지수는 unsigned byte라고 가정하고 지수에 127을 더한다.
// 따라서 1 + 127 = 128
// 결과 : 0b 1 10000000 1011000`0000`0000`0000`0000

```

프로그래밍할 때 부동소수점은 항상 `근사값`이라는 것을 기억해야 한다.

컴퓨터는 정확하게 실수의 값을 저장할 수 없다. 수가 커질수록 오차 범위도 매우 커지며 실수와 실수의 ==와 같은 비교는 매우 위험하므로 대안으로 오차 범위를 고려한 비교를 쓰도록 한다.

오차 범위를 고려할 때 `machine epsilon` (혹은 그냥 epsilon) 이라고 불리는 값을 사용한다. 이는 부동소수점 연산에서 반올림을 함 때 발생하는 오차의 상한이다. 즉 실수A와 실수B의 차가 machine epsilon보다 작거나 같다면 두 실수는 같은 값이라고 할 수 있다.


## 참고

https://docs.microsoft.com/ko-kr/cpp/build/why-floating-point-numbers-may-lose-precision?view=msvc-170

https://en.cppreference.com/w/cpp/types/numeric_limits/epsilon